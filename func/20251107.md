### **一、 驾驶操控优化 (Driving & Control)**

#### 1. 转向曲线/加速度 (Turning Curve)

*   **问题**: 当前的转向是线性的 (`turn_sensitivity` 是一个固定乘数)。这意味着摇杆推一半，转向速度就是最大的一半。在需要精细微调时，这可能过于灵敏；而在需要快速掉头时，可能又感觉不够快。
*   **新功能**: 使用非线性的数学曲线（如二次或三次函数）来处理转向输入。这样可以实现“摇杆小范围移动时，转向慢而精准；摇杆大范围移动时，转向快而猛烈”的效果。
*   **如何实现**: 在计算最终动力前，对转向值进行处理。

    ```cpp
    // 在 drivercontrol 的 switch 语句内部，替换原有的转向计算
    
    // 读取原始转向值
    int raw_turn_power = std::abs(A1) < JOYSTICK_DEADZONE ? 0 : A1;
    
    // 应用转向曲线 (三次函数示例)
    // 1. 将转向值归一化到 [-1, 1]
    float normalized_turn = raw_turn_power / 100.0;
    // 2. 应用三次函数 (pow(x, 3))
    float curved_turn = pow(normalized_turn, 3);
    // 3. 将结果转换回 [-100, 100] 的范围
    int final_turn_power = curved_turn * 100;
    
    // 使用 final_turn_power 来计算 left_final_power 和 right_final_power
    left_final_power = left_stick_vec + (final_turn_power * turn_sensitivity);
    right_final_power = left_stick_vec - (final_turn_power * turn_sensitivity);
    ```

#### 2. 一键回正 / 锁定朝向 (Hold Heading Button)

*   **问题**: 在激烈对抗或需要精准对准目标时，操作手很难完全保持机器人朝向不变。
*   **新功能**: 设置一个按键（例如 `L1` 或 `L2`），当按住它时，机器人会利用IMU陀螺仪自动修正方向，顽强地保持在按下瞬间的朝向上。这对于防御、瞄准或沿直线行驶非常有用。
*   **如何实现**:

    ```cpp
    // 在 drivercontrol 的 while 循环外定义一个变量
    float locked_heading = 0.0;
    
    // 在 while 循环内部
    if (Controller.ButtonL1.pressing()) { // 假设用L1键来锁定朝向
      if (!last_L1) { // 如果是刚刚按下L1
        locked_heading = getHeading(); // 记录当前朝向
      }
      
      // 使用一个简单的P控制器来修正方向
      float heading_error = locked_heading - getHeading();
      float turn_correction = heading_error * 1.5; // 1.5 是P系数, 可以调整
      
      // 将修正值应用到转向动力上 (这里只展示模式0的例子)
      left_final_power = left_stick_vec + turn_correction;
      right_final_power = left_stick_vec - turn_correction;
      
    } else {
      // 正常的用户控制逻辑
      // ...
    }
    ```

---

### **二、 机制功能自动化 (Mechanism Automation)**

#### 3. 自动进球与防卡球 (Smart Intake & Anti-Jam)

*   **问题**: 操作手需要一直按住进球键，并且如果球卡住了，需要手动反转。
*   **新功能**:
    *   **自动停止**: 利用您已有的距离传感器 (`Switch_Sensor`) 或颜色传感器 (`Color_Sensor`)。当按下 `R1` 后，进球机构启动，一旦传感器检测到物体进入，则自动停止，并给手柄一个短暂的震动反馈。
    *   **防卡球**: 在进球时，监控进球电机的实际转速 (`Motor_Intaker1.velocity(pct)`)。如果电机功率很高但转速很低，说明发生了堵塞。程序可以自动反转0.5秒，然后再尝试正转。
*   **如何实现 (自动停止)**:

    ```cpp
    // 在进球/得分机构控制部分
    if (R1 && !last_R1) { // 按一下R1就启动
      // ... 启动进球马达 ...
    }
    
    // 在循环中持续检测
    if (Switch_Sensor.distance(mm) < 50) { // 假设小于50mm代表有物体
      spinIntaker1(0); // 停止进球
      spinIntaker2(0);
      Controller.rumble("."); // 短暂震动一下
    }
    ```

#### 4. 一键组合宏 (One-Touch Macros)

*   **问题**: 一些得分动作可能需要多个步骤（例如：伸出气缸 -> 启动滚筒 -> 收回气缸）。操作手需要按顺序按好几个键。
*   **新功能**: 定义一个“宏”按键（例如 `B` 键），按一下即可自动执行一整套预设的动作序列。
*   **如何实现**: 这通常需要使用状态机或者计时器。

    ```cpp
    // 在 drivercontrol 循环外定义宏的状态
    int score_macro_state = 0;
    MyTimer macro_timer;
    
    // 在按键控制部分
    if (B && !last_B) { // 按下B键启动宏
      score_macro_state = 1; // 进入宏的第一步
      macro_timer.reset();
    }
    
    // 在循环中处理宏的状态
    if (score_macro_state == 1) {
      setPistonFront(true); // 第一步：伸出气缸
      if (macro_timer.getTime() > 200) { // 等待200毫秒
        score_macro_state = 2; // 进入第二步
      }
    } else if (score_macro_state == 2) {
      spinChange(100); // 第二步：启动滚筒
      if (macro_timer.getTime() > 700) { // 运行500毫秒
        score_macro_state = 3; // 进入第三步
      }
    } else if (score_macro_state == 3) {
      spinChange(0); // 第三步：停止滚筒
      setPistonFront(false); // 并收回气缸
      score_macro_state = 0; // 宏结束，返回初始状态
    }
    ```

---

### **三、 操作手反馈 (Driver Feedback)**

#### 5. 手柄震动反馈 (Controller Rumble)

*   **问题**: 操作手的所有信息都来自视觉和手柄屏幕，容易分心。
*   **新功能**: 在关键事件发生时，通过手柄震动给操作手提供触觉反馈。
*   **应用场景**:
    *   成功吸入物体时 (见功能3)。
    *   档位切换成功时。
    *   比赛进入最后15秒倒计时。
    *   自动程序运行出错或完成时。
*   **如何实现**: 非常简单，只需调用 `Controller.rumble()` 函数。

    ```cpp
    // 例如，在档位切换成功后
    if (gear_changed) {
      Controller.rumble("."); // 一个短促的点震动
      // ... 更新屏幕的代码 ...
    }
    
    // 例如，在主循环的某个地方检查比赛时间
    if (Competition.timeleft() < 15 && Competition.timeleft() > 14) {
       Controller.rumble("---"); // 一个长震动提示
    }
    ```